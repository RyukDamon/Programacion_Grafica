<!DOCTYPE html>
<head>
</head>
<body>
    <canvas id = "webglcanvas" style = "border: none" width = "500"
     height = "500"></canvas>   
    <script id = "vs" type = "vertex">
        #version 300 es
        uniform mat4 uMatrizProyeccion;
        uniform mat4 uMatrizVista;
        uniform mat4 uMatrizModelo;
        layout (location = 0) in vec2 aVertices; // (x,y)
        void main() {
            gl_Position = uMatrizProyeccion * uMatrizVista*  
            uMatrizModelo * vec4(aVertices, 0.0, 1.0); // (x,y,z,1); coordenada normalizada
        }
    </script>
    <script id = "fs" type = "fragment">
        #version 300 es
        precision mediump float;
        uniform vec4 uColor; // r,g,b,a
        out vec4 color;
        void main() {
            color = uColor;
        }
    </script>
    <script>
        // + Matriz Identidad 
        function identidad(r) {
          r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
          r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
          r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

        /* Proyeccion Paralela - gl Orthogonal */
        function ortho(r, izq, der, abj, arr, cerca, lejos) {
          r[0] = 2/(der - izq); r[4] =             0; r[ 8] =                  0; r[12] =         -(der + izq)/(der - izq);
          r[1] =             0; r[5] = 2/(arr - abj); r[ 9] =                  0; r[13] =         -(arr + abj)/(arr - abj);
          r[2] =             0; r[6] =             0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
          r[3] =             0; r[7] =             0; r[11] =                  0; r[15] =                                1;
        }

        function main(){
            // + definimos en js
            let uMatrizProyeccion;
            let uMatrizVista;
            let uMatrizModelo;

            // + Matrices
            let MatrizProyeccion = new Array(16); //4x4 elementos
            let MatrizVista = new Array(16); 
            let MatrizModelo = new Array(16); 

            var canvas = document.getElementById("webglcanvas");
            var gl = canvas.getContext("webgl2");

            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            // compila shader de vertice
            var shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(shaderDeVertice, 
                document.getElementById("vs").text.trim());
            gl.compileShader(shaderDeVertice); 

            // compila shader de fragmento
            var shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(shaderDeFragmento, 
                document.getElementById("fs").text.trim());
            gl.compileShader(shaderDeFragmento); 

            // enlazar ambos
            var programaID = gl.createProgram();
            gl.attachShader(programaID, shaderDeVertice); 
            gl.attachShader(programaID, shaderDeFragmento);
            gl.linkProgram(programaID);

            gl.useProgram(programaID);

            // geometria
            var vertices = [
                -0.5,  0.0,     // A = 0
                 0.0, -0.5,     // B = 1
                 0.5,  0.0,     // C = 2
                 0.0,  0.5,     // D = 3
            ];

            //AGREGAMOS INDICES
            var indices = [
                0, 1, 2,   //genera primer triangulo
                0, 2, 3,   //genera segundo triangulo

            ];

            var triangulo = gl.createVertexArray();
            gl.bindVertexArray(triangulo);

            var codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

            //HACEMOS USO ARREGLO INDICES
            let codigoDeIndices = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);


            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            //AGREGAMOS LA LINEA
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,null);

            let uColor = gl.getUniformLocation(programaID, "uColor");
            //+ uniendo variable js 
            uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
            uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
            uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");

            //+ definimos la matriz de proyeccion y enviamos
            ortho(MatrizProyeccion, -1, 1, -1, 1, -1, 1); //trabajar con cualquier resol
            gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);


            //+ iniciamos matrices y enviamos a shader
            identidad(MatrizVista);
            gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);

            identidad(MatrizModelo);
            gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

            

            gl.clearColor(255/255, 177/255, 100/255, 1); // r g b a 255 177 100
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.bindVertexArray(triangulo);

            //LE DAMOS COLOR RGBA ROJO PRIMER TRIANGULO
            gl.uniform4f(uColor,1, 0, 0, 1);
            //AHOARA UTILIZAMOS DRAW ELEMENTS
            gl.drawElements(gl.TRIANGLES, 3, gl.UNSIGNED_SHORT, 0); // 3 = cantidad indices    0 = desde el byte cero
            
            //LE DAMOS COLOR RGBA 2DO TRIANGULO
            gl.uniform4f(uColor,0, 0, 1, 1);
            //AHOARA UTILIZAMOS DRAW ELEMENTS
            gl.drawElements(gl.TRIANGLES, 3, gl.UNSIGNED_SHORT, 6); // 3 = cantidad indices a tomar en cuenta, 6 = desde que byte toma cuenta
        

            gl.bindVertexArray(null);

        }
        window.onload = main;
    </script>
</body>
</html>